# This is the central, reusable workflow that contains the core JMeter logic.
# All application-specific workflows will call this file.
name: "Reusable JMeter Load Test Framework"

on:
  workflow_call:
    # ----------------------------------------------------
    # Configuration Inputs (passed from the dispatcher)
    # ----------------------------------------------------
    inputs:
      app_name:
        description: "Application name (e.g., app1)"
        required: true
        type: string
      environment_name:
        description: "Environment to test (e.g., dev, qa, prod)"
        required: true
        type: string
      jmx_file:
        description: "Which JMeter test plan to run? (Path relative to applications/$APP_NAME/)"
        required: true
        type: string
      test_type:
        description: "Choose test type (load/cleanup)"
        required: true
        type: string
      runners_to_use:
        description: "Number of parallel runners to use (1-4)"
        required: true
        type: number
      test_name:
        description: "Optional test name; if blank, YYYYMMDDHHMM will be used"
        required: false
        type: string
        default: ""
      monitor_system:
        description: "Monitor runner CPU/memory usage during test? true/false"
        required: false
        type: boolean
        default: false
      cleanup_days:
        description: "Delete reports older than X days (cleanup mode)"
        required: false
        type: number
        default: 7
      print_machine_info:
        description: "Set true to print machine details"
        required: false
        type: boolean
        default: false

    # ----------------------------------------------------
    # Secrets (MANDATORY: Secrets must be explicitly defined here)
    # ----------------------------------------------------
    secrets:
      # Generic secrets used by the framework
      API_SECRET_KEY:
        description: "The API Key needed for authentication."
        required: false
      AWS_ACCESS_KEY:
        description: "The AWS Access Key for the current environment."
        required: false
      

env:
  JMETER_VERSION: "5.6.3"          # JMeter version to install
  REPORT_DIR: "./reports"          # Base directory for runner results
  JMETER_HOME: "$HOME/jmeter"      # JMeter installation directory

# =========================================================
# Job 1: Determine final test name (Uses passed input)
# =========================================================
jobs:
  set-test-name:
    runs-on: ubuntu-latest
    outputs:
      final_test_name: ${{ steps.determine.outputs.final_test_name }}

    steps:
      - id: determine
        run: |
          # Use user-provided test_name or fallback to timestamp
          if [ -n "${{ inputs.test_name }}" ]; then
            NAME="${{ inputs.test_name }}"
          else
            NAME=$(date +%Y%m%d%H%M)
          fi

          # Sanitize test name
          SAFE_NAME=$(echo "$NAME" | sed 's/[^a-zA-Z0-9_-]/_/g')

          # Export for downstream jobs
          echo "final_test_name=$SAFE_NAME" >> $GITHUB_OUTPUT
          echo "✅ Test name set to: $SAFE_NAME"

---
# =========================================================
# Job 2: Run JMeter (multi-runner)
# =========================================================
  run-jmeter:
    needs: set-test-name
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        # Strategy is fixed at 4 runners. The 'Skip unused runners' step handles scaling down.
        runner_index: [1,2,3,4]

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # -------------------------------
      # Skip unused runners
      # -------------------------------
      - name: Skip unused runner jobs
        # Convert input (number) to a raw number for comparison
        if: ${{ matrix.runner_index > inputs.runners_to_use }}
        run: |
          echo "Skipping runner ${{ matrix.runner_index }} as only ${{ inputs.runners_to_use }} runners were requested."
          exit 0

      # -------------------------------
      # Print machine info if requested (Optional)
      # -------------------------------
      - name: Print machine details
        if: ${{ inputs.print_machine_info }}
        run: |
          echo "===== Machine Info ====="
          echo "CPU cores: $(nproc)"
          echo "Memory: $(free -h)"
          echo "========================"

      # -------------------------------
      # Load app-specific environment variables (.env)
      # -------------------------------
      - name: Load environment variables
        shell: bash
        run: |
          APP_NAME="${{ inputs.app_name }}"
          ENV_NAME="${{ inputs.environment_name }}"
          JMX_FILE="${{ inputs.jmx_file }}"
          echo "ℹ️ Running test for app: $APP_NAME in environment: $ENV_NAME, using script: $JMX_FILE"

          # Path to app-specific, environment-scoped config file (e.g., applications/app1/dev.env)
          ENV_FILE="applications/$APP_NAME/$ENV_NAME.env"

          if [ -f "$ENV_FILE" ]; then
            echo "✅ Loading environment variables from $ENV_FILE"
            # Read variables (e.g., THREADS, DURATION) and export them to the current runner environment
            set -o allexport
            grep -v '^#' "$ENV_FILE" | grep -v '^\s*$' | while read -r line; do
              if [[ "$line" == *"="* ]]; then
                varname=$(echo "$line" | cut -d '=' -f1)
                value=$(echo "$line" | cut -d '=' -f2-)
                # Export to $GITHUB_ENV for use in subsequent steps
                echo "$varname=$value" >> $GITHUB_ENV
                echo "  Loaded $varname"
              fi
            done
            set +o allexport
          else
            echo "⚠️ Environment config file not found: $ENV_FILE. Using defaults or empty values."
            # Set minimum defaults to prevent script failure if file is missing
            echo "DURATION=120" >> $GITHUB_ENV
            echo "THREADS=10" >> $GITHUB_ENV
            echo "RAMPUP=60" >> $GITHUB_ENV
          fi
          
          # Export workflow inputs for use in Run JMeter step
          echo "APP_NAME=${{ inputs.app_name }}" >> $GITHUB_ENV
          echo "JMX_FILE=${{ inputs.jmx_file }}" >> $GITHUB_ENV


      # -------------------------------
      # Validate JMeter test plan exists
      # -------------------------------
      - name: Validate JMeter test plan exists
        id: validate_jmx
        run: |
          JMX_PATH="applications/${{ env.APP_NAME }}/${{ env.JMX_FILE }}"
          if [ ! -f "$JMX_PATH" ]; then
            echo "❌ JMeter test plan not found at: $JMX_PATH"
            exit 1
          fi
          echo "✅ JMeter test plan found."

      # -------------------------------
      # Install JMeter
      # -------------------------------
      - name: Install JMeter
        run: |
          echo "Installing JMeter ${{ env.JMETER_VERSION }}..."
          wget -q https://archive.apache.org/dist/jmeter/binaries/apache-jmeter-${{ env.JMETER_VERSION }}.zip
          unzip -q apache-jmeter-${{ env.JMETER_VERSION }}.zip
          mv apache-jmeter-${{ env.JMETER_VERSION }} ${{ env.JMETER_HOME }}
          echo "${{ env.JMETER_HOME }}/bin" >> $GITHUB_PATH
          rm apache-jmeter-${{ env.JMETER_VERSION }}.zip
          echo "✅ JMeter installed to ${{ env.JMETER_HOME }}"

      # -------------------------------
      # Install JMeter Plugins (if needed)
      # -------------------------------
      - name: Install JMeter Plugins
        run: |
          echo "Installing JMeter Plugins..."
          # Install Plugins Manager
          curl -sS https://repo1.maven.org/maven2/kg/apc/jmeter-plugins-manager/1.8/jmeter-plugins-manager-1.8.jar -o ${{ env.JMETER_HOME }}/lib/ext/jmeter-plugins-manager-1.8.jar
          
          # Install the 'Custom Thread Groups' plugin (e.g., for better concurrency control)
          ${{ env.JMETER_HOME }}/bin/PluginsManagerCMD.sh install jpgc-casutg
          echo "✅ JMeter Plugins installed."

      # -------------------------------
      # Run JMeter Test
      # -------------------------------
      - name: Run JMeter Test
        id: run_test
        run: |
          TEST_NAME="${{ needs.set-test-name.outputs.final_test_name }}"
          TIMESTAMP=$(date +%Y%m%d-%H%M%S)
          RESULT_DIR="${{ env.REPORT_DIR }}/${TEST_NAME}-runner-${{ matrix.runner_index }}-$TIMESTAMP"
          mkdir -p "$RESULT_DIR"
          
          # Use variables from environment (.env file) and secrets from dispatcher (via secrets context)
          jmeter -n \
            -t "applications/$APP_NAME/$JMX_FILE" \
            -l "$RESULT_DIR/results-runner-${{ matrix.runner_index }}.jtl" \
            -e -o "$RESULT_DIR/html-report" \
            -j "$RESULT_DIR/jmeter-runner-${{ matrix.runner_index }}.log" \
            -Jjmeter.save.saveservice.autoflush=true \
            -JDURATION="${{ env.DURATION }}" \
            -JTHREADS="${{ env.THREADS }}" \
            -JRAMPUP="${{ env.RAMPUP }}" \
            -JAPI_KEY="${{ secrets.API_SECRET_KEY }}" \
            -JAWS_ACCESS_KEY="${{ secrets.AWS_ACCESS_KEY }}" \
            -JAPP_NAME="$APP_NAME"
            
          echo "result_dir=$RESULT_DIR" >> $GITHUB_OUTPUT
      
      # -------------------------------
      # Package runner artifacts
      # -------------------------------
      - name: Package runner artifacts
        id: package_artifacts
        run: |
          cd ${{ steps.run_test.outputs.result_dir }}
          ZIP_NAME="${{ needs.set-test-name.outputs.final_test_name }}-runner-${{ matrix.runner_index }}.zip"
          zip -r "$ZIP_NAME" .
          
          cd -
          echo "zip_path=${{ steps.run_test.outputs.result_dir }}/$ZIP_NAME" >> $GITHUB_OUTPUT
          echo "✅ Runner artifacts packaged into $ZIP_NAME"

      # -------------------------------
      # Upload Runner Artifact
      # -------------------------------
      - name: Upload Runner Artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ needs.set-test-name.outputs.final_test_name }}-runner-${{ matrix.runner_index }}
          path: ${{ steps.package_artifacts.outputs.zip_path }}
          retention-days: 5

---
# =========================================================
# Job 3: Aggregate reports (If test_type is 'load')
# =========================================================
  aggregate-reports:
    needs: run-jmeter
    runs-on: ubuntu-latest
    if: ${{ inputs.test_type == 'load' }}

    steps:
      - name: Download all runner artifacts
        uses: actions/download-artifact@v4
        with:
          path: ./downloaded-artifacts
          pattern: ${{ needs.set-test-name.outputs.final_test_name }}-runner-*
          merge-multiple: true

      - name: Aggregate JTL files (Requires custom script)
        run: |
          echo "Starting aggregation of all runner JTL files..."
          # Mock creation of master.jtl for HTML report generation
          echo "<?xml version=\"1.0\" encoding=\"UTF-8\"?><testResults version=\"1.2\">" > master.jtl
          # Find all JTL files and append them, skipping the header line
          find ./downloaded-artifacts -name "results-runner-*.jtl" -exec tail -n +2 {} \; >> master.jtl
          echo "</testResults>" >> master.jtl
          echo "✅ Master JTL created."

      - name: Install JMeter for Report Generation
        run: |
          echo "Installing JMeter ${{ env.JMETER_VERSION }} for report generation..."
          wget -q https://archive.apache.org/dist/jmeter/binaries/apache-jmeter-${{ env.JMETER_VERSION }}.zip
          unzip -q apache-jmeter-${{ env.JMETER_VERSION }}.zip
          mv apache-jmeter-${{ env.JMETER_VERSION }} ./jmeter-report-gen
          echo "./jmeter-report-gen/bin" >> $GITHUB_PATH

      - name: Generate Final HTML Report
        run: |
          REPORT_OUTPUT="./final-html-report"
          jmeter -g master.jtl -o "$REPORT_OUTPUT"
          echo "✅ Final HTML Report generated in $REPORT_OUTPUT"

      - name: Upload Final Consolidated Report
        uses: actions/upload-artifact@v4
        with:
          name: ${{ needs.set-test-name.outputs.final_test_name }}-CONSOLIDATED-REPORT
          path: ./final-html-report
          retention-days: 30
          
      - name: Complete Test Run
        run: echo "Test run completed successfully for ${{ needs.set-test-name.outputs.final_test_name }}."

---
# =========================================================
# Job 4: Cleanup (If test_type is 'cleanup')
# =========================================================
  cleanup-artifacts:
    if: ${{ inputs.test_type == 'cleanup' }}
    runs-on: ubuntu-latest
    
    steps:
      - name: Find and delete old artifacts
        uses: actions/github-script@v7
        with:
          script: |
            const days = parseInt('${{ inputs.cleanup_days }}');
            const cutoff = new Date();
            cutoff.setDate(cutoff.getDate() - days);

            console.log(`Searching for artifacts older than ${days} days (${cutoff.toISOString()}).`);

            const listArtifacts = await github.rest.actions.listArtifactsForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
            });

            const artifactsToDelete = listArtifacts.data.artifacts.filter(artifact => {
              const createdDate = new Date(artifact.created_at);
              return createdDate < cutoff;
            });

            if (artifactsToDelete.length === 0) {
              console.log('No artifacts found for deletion.');
              return;
            }

            console.log(`Found ${artifactsToDelete.length} artifacts to delete.`);

            for (const artifact of artifactsToDelete) {
              console.log(`Deleting artifact: ${artifact.name} (Created: ${artifact.created_at})`);
              try {
                await github.rest.actions.deleteArtifact({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  artifact_id: artifact.id,
                });
                console.log(`Successfully deleted artifact ID: ${artifact.id}`);
              } catch (error) {
                console.error(`Failed to delete artifact ID: ${artifact.id}. Error: ${error.message}`);
              }
            }
            console.log('Artifact cleanup completed.');
