name: "JMeter Load Test (Multi-Runner)"

run-name: >
  JMeter Workflow: ${{ github.event.inputs.test_name }}

permissions:
  actions: write
  contents: read
  
on:
  workflow_dispatch:
    inputs:
      app_name:
        description: "Application name (e.g., app1, app2)"
        required: true
      jmx_file:
        description: "Which JMeter test plan to run?"
        required: false
        default: "sample_jmeter.jmx"
        type: choice
        options:
          - sample_jmeter.jmx
          - High_TPS_Runner.jmx
      test_type:
        description: "Choose test type (load/cleanup)"
        required: true
        type: choice
        options:
          - load
          - cleanup
      environment:
        description: "Choose environment type (dev/prod)"
        required: true
        type: choice
        default: "dev"
        options:
          - dev
          - test
      runners_to_use:
        description: "Number of parallel runners to use (1‚Äì4)"
        required: true
        type: choice
        options:
          - '1'
          - '2'
          - '3'
          - '4'
      test_name:
        description: "Optional test name; if blank, YYYYMMDDHHMM will be used"
        required: false
        default: ""
      environment_name: # <-- NEW INPUT
        description: "Select environment (test or prod)"
        required: true
        type: choice
        options:
          - test
          - prod
      monitor_system:
        description: "Monitor runner CPU/memory usage during test? true/false"
        required: false
        type: choice
        options:
          - "true"
          - "false"
        default: "false"
      cleanup_days:
        description: "Delete reports older than X days (cleanup mode)"
        required: false
        default: "7"
      print_machine_info:
        description: "Set true to print machine details"
        required: false
        type: choice
        options:
          - "true"
          - "false"

env:
  JMETER_VERSION: "5.6.3"
  SCRIPTS_DIR: "applications"
  REPORT_DIR: "./reports"
  JMETER_HOME: "$HOME/jmeter"

jobs:
  # =========================================================
  # Job 1: Determine final test name
  # =========================================================
  set-test-name:
    runs-on: ubuntu-latest
    outputs:
      final_test_name: ${{ steps.determine.outputs.final_test_name }}

    steps:
      - id: determine
        run: |
          if [ -n "${{ github.event.inputs.test_name }}" ]; then
            NAME="${{ github.event.inputs.test_name }}"
          else
            NAME=$(date +%Y%m%d%H%M)
          fi
          SAFE_NAME=$(echo "$NAME" | sed 's/[^a-zA-Z0-9_-]/_/g')
          echo "final_test_name=$SAFE_NAME" >> $GITHUB_OUTPUT
          echo "‚úÖ Test name set to: $SAFE_NAME"

  # =========================================================
  # Job 2: Run JMeter runners
  # =========================================================
  run-jmeter:
    if: ${{ github.event.inputs.test_type == 'load' }}
    needs: set-test-name
    runs-on: ubuntu-latest
    
    # -----------------------------
    # Use environment-specific secrets/variables
    # -----------------------------
    environment: ${{ github.event.inputs.environment_name }}

    strategy:
      fail-fast: false
      matrix:
        runner_index: [1,2,3,4]

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Skip unused runner jobs
        if: ${{ matrix.runner_index > fromJSON(github.event.inputs.runners_to_use) }}
        run: |
          echo "Skipping runner ${{ matrix.runner_index }}"
          exit 0

      - name: Print machine details
        if: ${{ github.event.inputs.print_machine_info == 'true' }}
        run: |
          echo "===== Machine Info ====="
          echo "CPU cores: $(nproc)"
          echo "Memory: $(free -h)"
          echo "Public IP: $(curl -s ifconfig.me)"
          curl -s https://ipapi.co/json/
          echo "========================"

      - name: Load local environment variables (from .env file)
        if: ${{ matrix.runner_index <= fromJSON(github.event.inputs.runners_to_use) }}
        shell: bash
        run: |
          APP_NAME="${{ github.event.inputs.app_name }}"
          ENV_FILE="./$APP_NAME/.env"
          # Default values (can be overridden by the next step or provided to jmeter command)
          DURATION=""
          THREADS=""
          RAMPUP=""
          AUTH_HEADER=""
          API_KEY=""
          
          if [ -f "$ENV_FILE" ]; then
            echo "‚úÖ Loading environment variables from $ENV_FILE"
            set -o allexport
            grep -v '^#' "$ENV_FILE" | grep -v '^\s*$' | while read -r line; do
              if [[ "$line" == *"="* ]]; then
                varname=$(echo "$line" | cut -d '=' -f1)
                value=$(echo "$line" | cut -d '=' -f2-)
                export "$varname=$value"
                echo "    Loaded $varname"
              fi
            done
            set +o allexport
          fi
          
          # Export to GitHub Environment (for use in subsequent steps)
          echo "APP_NAME=$APP_NAME" >> $GITHUB_ENV
          echo "DURATION=${DURATION:-}" >> $GITHUB_ENV
          echo "THREADS=${THREADS:-}" >> $GITHUB_ENV
          echo "RAMPUP=${RAMPUP:-}" >> $GITHUB_ENV
          echo "AUTH_HEADER=${AUTH_HEADER:-}" >> $GITHUB_ENV
          echo "API_KEY=${API_KEY:-}" >> $GITHUB_ENV

      # -----------------------------
      # Map Environment Variables Dynamically <-- NEW STEP
      # -----------------------------
      - name: Map Environment Variables Dynamically
        if: ${{ matrix.runner_index <= fromJSON(github.event.inputs.runners_to_use) }}
        shell: bash
        env:
          # Use vars context to retrieve dynamic variables based on app_name input
          APP_BASE_URL: ${{ vars[format('{0}_{1}_BASE_URL', github.event.inputs.app_name, github.event.inputs.environment)] }}
          APP_TARGET_HOST: ${{ vars[format('{0}_{1}_TARGET_HOST', github.event.inputs.app_name, github.event.inputs.environment)] }}
          APP_REGION: ${{ vars[format('{0}_{1}_REGION', github.event.inputs.app_name, github.event.inputs.environment)] }}
          # Use secrets context to retrieve dynamic secrets
          APP_ACCESS_KEY: ${{ secrets[format('{0}_{1}_ACCESS_KEY', github.event.inputs.app_name, github.event.inputs.environment)] }}
          APP_SECRET_KEY: ${{ secrets[format('{0}_{1}_SECRET_KEY', github.event.inputs.app_name, github.event.inputs.environment)] }}

          APP_BASE_ENDPOINT: ${{ vars[format('{0}_{1}_ENDPOINT', github.event.inputs.app_name, github.event.inputs.environment)] }}
          APP_BASE_REGION: ${{ vars[format('{0}_{1}_REGIONS', github.event.inputs.app_name, github.event.inputs.environment)] }}
          
          APP_UPPER: ${{ github.event.inputs.app_name }} # Pass app_name to the shell
        run: |
          # Convert app_name input to uppercase (e.g., "app1" -> "APP1")
          APP_UPPER=$(echo "$APP_UPPER" | tr '[:lower:]' '[:upper:]')

          # Export values to GitHub Actions environment for subsequent steps
          # NOTE: These values will override any generic ones loaded from .env if the names clash.
          echo "BASE_URL=$APP_BASE_URL" >> $GITHUB_ENV
          echo "TARGET_HOST=$APP_TARGET_HOST" >> $GITHUB_ENV
          echo "AWS_REGION=$APP_REGION" >> $GITHUB_ENV
          echo "AWS_ACCESS_KEY_ID=$APP_ACCESS_KEY" >> $GITHUB_ENV
          echo "AWS_SECRET_ACCESS_KEY=$APP_SECRET_KEY" >> $GITHUB_ENV # NOTE: GitHub automatically masks secrets in logs

          echo "APP_BASE_ENDPOINT=$APP_BASE_ENDPOINT" >> $GITHUB_ENV
          echo "APP_BASE_REGION=$APP_BASE_REGION" >> $GITHUB_ENV

          echo "‚úÖ Environment variables mapped for $APP_UPPER"
          echo "BASE_URL=$APP_BASE_URL"
          echo "TARGET_HOST=$APP_TARGET_HOST"
          echo "New REGION=$APP_BASE_REGION"
          
          echo "‚úÖ APP_BASE_ENDPOINT exists: $APP_BASE_ENDPOINT"
          
      - name: Check JMeter test plan exists
        if: ${{ matrix.runner_index <= fromJSON(github.event.inputs.runners_to_use) }}
        run: |
          TEST_PLAN="${{ env.SCRIPTS_DIR }}/$APP_NAME/scripts/${{ github.event.inputs.jmx_file }}"
          if [ ! -f "$TEST_PLAN" ]; then
            echo "‚ùå Test plan $TEST_PLAN not found!"
            exit 1
          fi
          echo "‚úÖ Test plan exists: $TEST_PLAN"

      - name: Install JMeter & Plugins
        if: ${{ matrix.runner_index <= fromJSON(github.event.inputs.runners_to_use) }}
        run: |
          JMETER_HOME="$HOME/jmeter"
          mkdir -p "$JMETER_HOME"
          curl -sL "https://downloads.apache.org/jmeter/binaries/apache-jmeter-${{ env.JMETER_VERSION }}.tgz" -o jmeter.tgz
          tar -xzf jmeter.tgz -C "$JMETER_HOME" --strip-components=1
          mkdir -p "$JMETER_HOME/lib/ext"

          # Dummy plugin
          curl -L -o /tmp/jpgc-dummy-0.4.zip https://jmeter-plugins.org/files/packages/jpgc-dummy-0.4.zip
          unzip -o /tmp/jpgc-dummy-0.4.zip -d /tmp/dummy-plugin
          find /tmp/dummy-plugin -name "*.jar" -exec cp {} "$JMETER_HOME/lib/ext/" \;

          # Ultimate Thread Group plugin
          curl -L -o /tmp/jpgc-ultimate-thread-group-3.0.zip https://jmeter-plugins.org/files/packages/jpgc-casutg-3.1.1.zip
          unzip -o /tmp/jpgc-ultimate-thread-group-3.0.zip -d /tmp/ultimate-plugin
          find /tmp/ultimate-plugin -name "*.jar" -exec cp {} "$JMETER_HOME/lib/ext/" \;

          # CMDRunner 2.3
          curl -L -o "$JMETER_HOME/lib/cmdrunner-2.3.jar" https://repo1.maven.org/maven2/kg/apc/cmdrunner/2.3/cmdrunner-2.3.jar

          # Plugins Manager
          curl -sL https://jmeter-plugins.org/get/ -o "$JMETER_HOME/lib/ext/jmeter-plugins-manager.jar"

          # Install MergeResults plugin
          java -cp "$JMETER_HOME/lib/ext/jmeter-plugins-manager.jar" org.jmeterplugins.repository.PluginManagerCMDInstaller || true
          chmod +x "$JMETER_HOME/bin/PluginsManagerCMD.sh"
          "$JMETER_HOME/bin/PluginsManagerCMD.sh" install jpgc-mergeresults

      - name: Optional system monitoring
        if: ${{ github.event.inputs.monitor_system == 'true' && matrix.runner_index <= fromJSON(github.event.inputs.runners_to_use) }}
        run: |
          sudo apt-get install -y sysstat # Ensure mpstat is available
          mkdir -p "${{ env.REPORT_DIR }}"
          LOG_FILE="${{ env.REPORT_DIR }}/runner-${{ matrix.runner_index }}-system.log"
          echo "timestamp,cpu_user,cpu_system,cpu_idle,mem_used,mem_free" > $LOG_FILE
          monitor() {
            while true; do
              ts=$(date +"%Y-%m-%d %H:%M:%S")
              cpu=$(mpstat 1 1 | awk '/Average/ {print $3","$5","$12}')
              mem=$(free -m | awk '/Mem:/ {print $3","$4}')
              echo "$ts,$cpu,$mem" >> $LOG_FILE
              sleep 180
            done
          }
          monitor &
          echo $! > /tmp/monitor_pid.txt

      - name: Run JMeter Test
        id: run_test
        if: ${{ matrix.runner_index <= fromJSON(github.event.inputs.runners_to_use) }}
        run: |
          TEST_NAME="${{ needs.set-test-name.outputs.final_test_name }}"
          TIMESTAMP=$(date +%Y%m%d-%H%M%S)
          RESULT_DIR="${{ env.REPORT_DIR }}/${TEST_NAME}-runner-${{ matrix.runner_index }}-$TIMESTAMP"
          mkdir -p "$RESULT_DIR"

          "$HOME/jmeter/bin/jmeter" -n \
            -t "${{ env.SCRIPTS_DIR }}/$APP_NAME/scripts/${{ github.event.inputs.jmx_file }}" \
            -l "$RESULT_DIR/results-runner-${{ matrix.runner_index }}.jtl" \
            -e -o "$RESULT_DIR/html-report" \
            -j "$RESULT_DIR/jmeter-runner-${{ matrix.runner_index }}.log" \
            -Jjmeter.save.saveservice.autoflush=true \
            -JAPP_NAME="$APP_NAME" \
            -JDURATION="$DURATION" \
            -JTHREADS="$THREADS" \
            -JRAMPUP="$RAMPUP" \
            -JAUTH_HEADER="$AUTH_HEADER" \
            -JAPI_KEY="$API_KEY" \
            -JBASE_URL="$BASE_URL" \
            -JTARGET_HOST="$TARGET_HOST" \
            -JAWS_REGION="$AWS_REGION" \
            -JAWS_ACCESS_KEY_ID="$AWS_ACCESS_KEY_ID" \
            -JAWS_SECRET_ACCESS_KEY="$AWS_SECRET_ACCESS_KEY"

          echo "result_dir=$RESULT_DIR" >> $GITHUB_OUTPUT

      - name: Stop system monitoring
        if: ${{ github.event.inputs.monitor_system == 'true' && matrix.runner_index <= fromJSON(github.event.inputs.runners_to_use)}}
        run: |
          if [ -f /tmp/monitor_pid.txt ]; then
            kill $(cat /tmp/monitor_pid.txt) || true
            rm /tmp/monitor_pid.txt
          fi

      - name: Package Runner Artifacts (with system log)
        if: ${{ matrix.runner_index <= fromJSON(github.event.inputs.runners_to_use) }}
        run: |
          ZIP_NAME="runner-${{ matrix.runner_index }}-results.zip"
          mkdir -p upload
          zip -r "upload/$ZIP_NAME" "${{ steps.run_test.outputs.result_dir }}" "${{ env.REPORT_DIR }}/runner-${{ matrix.runner_index }}-system.log" || true
          echo "Packaged runner ZIP including system log: upload/$ZIP_NAME"

      - name: Upload Runner Artifact
        uses: actions/upload-artifact@v4
        with:
          name: jmeter-results-runner-${{ matrix.runner_index }}
          path: upload/*.zip
          retention-days: ${{ github.event.inputs.cleanup_days }}

# =========================================================
# Job 3: Aggregate runner JTLs
# =========================================================
  aggregate-results:
    if: ${{ github.event.inputs.test_type == 'load' && fromJSON(github.event.inputs.runners_to_use) > 1 }}
    name: Aggregate JMeter Results
    needs: run-jmeter
    runs-on: ubuntu-latest
    steps:
      # 1) checkout so any utilities (if needed) are available
      - name: Checkout repository
        uses: actions/checkout@v4
  
      # 2) setup Java (JMeter needs a JVM)
      - name: Setup Java 17
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: '17'
  
      # 3) install basic tools (curl/unzip) that we'll need
      - name: Install OS dependencies
        run: sudo apt-get update && sudo apt-get install -y curl unzip
  
      # 4) install JMeter (we'll need it for HTML report generation regardless)
      - name: Install JMeter
        run: |
          set -e
          JMETER_VERSION=5.6.3
          echo "Installing JMeter $JMETER_VERSION..."
          curl -sL "https://downloads.apache.org/jmeter/binaries/apache-jmeter-${JMETER_VERSION}.tgz" -o jmeter.tgz
          tar -xzf jmeter.tgz
          mv "apache-jmeter-${JMETER_VERSION}" "$HOME/jmeter"
          echo "$HOME/jmeter/bin" >> $GITHUB_PATH
          echo "JMeter installed: $HOME/jmeter"
  
      # 5) Download artifacts that runner jobs uploaded earlier
      - name: Download matrix artifacts (from runners)
        uses: actions/download-artifact@v4
        with:
          path: merged-results
  
      # 6) Debug listing so you can see exactly what's downloaded
      - name: Debug list merged-results contents
        run: |
          echo "===== merged-results top-level ====="
          ls -la merged-results || true
          echo "===== recursive listing ====="
          find merged-results -type f -maxdepth 5 -print || true
  
      # 7) Unzip any ZIP files that may be inside the merged-results folders
      - name: Unzip any runner zips (if present)
        shell: bash
        run: |
          set -e
          mkdir -p merged-results/unzipped
          # Find all zip files under merged-results and unzip them
          shopt -s globstar || true
          ZIP_FOUND=false
          while IFS= read -r -d '' z; do
            ZIP_FOUND=true
            echo "Unzipping: $z"
            unzip -o "$z" -d merged-results/unzipped/ || true
          done < <(find merged-results -type f -name "*.zip" -print0)
          if [ "$ZIP_FOUND" = "false" ]; then
            echo "No runner ZIP files found; skipping unzip."
          else
            echo "Unzipped runner ZIPs into merged-results/unzipped/"
            echo "Contents of merged-results/unzipped/:"
            find merged-results/unzipped -type f -print | sed -n '1,200p' || true
          fi
  
      # 8) Try to install CMDRunner + MergeResults plugin
      - name: Try install CMDRunner + MergeResults (best-effort)
        id: install_plugins
        shell: bash
        run: |
          set -e
          JMETER_HOME="$HOME/jmeter"
          echo "Attempting to install CMDRunner and MergeResults plugin (best-effort)..."
  
          # Download CMDRunner jar (used for ReportsGenerator/merging)
          curl -L -s -o "$JMETER_HOME/lib/cmdrunner-2.3.jar" \
            https://repo1.maven.org/maven2/kg/apc/cmdrunner/2.3/cmdrunner-2.3.jar || {
              echo "‚ö†Ô∏è Could not download cmdrunner jar"
              echo "installed=false" >> $GITHUB_OUTPUT
              exit 0
            }
  
          # Download plugins manager
          curl -L -s -o "$JMETER_HOME/lib/ext/jmeter-plugins-manager.jar" https://jmeter-plugins.org/get/ || {
            echo "‚ö†Ô∏è Could not download jmeter-plugins-manager.jar"
            echo "installed=false" >> $GITHUB_OUTPUT
            exit 0
          }
  
          # Use installer to get PluginsManagerCMD.sh
          java -cp "$JMETER_HOME/lib/ext/jmeter-plugins-manager.jar" org.jmeterplugins.repository.PluginManagerCMDInstaller || true
  
          # Verify the helper script is present; make it executable
          if [ -f "$JMETER_HOME/bin/PluginsManagerCMD.sh" ]; then
            chmod +x "$JMETER_HOME/bin/PluginsManagerCMD.sh" || true
            # Try to install MergeResults plugin
            echo "Installing jpgc-mergeresults via PluginsManagerCMD.sh..."
            # run with timeout to avoid indefinite hangs
            timeout 120 "$JMETER_HOME/bin/PluginsManagerCMD.sh" install jpgc-mergeresults && {
              echo "installed=true" >> $GITHUB_OUTPUT
              echo "MergeResults plugin installed."
              exit 0
            } || {
              echo "‚ö†Ô∏è PluginsManagerCMD.sh install failed or timed out"
              echo "installed=false" >> $GITHUB_OUTPUT
              exit 0
            }
          else
            echo "‚ö†Ô∏è PluginsManagerCMD.sh not found after installer"
            echo "installed=false" >> $GITHUB_OUTPUT
            exit 0
          fi
  
        # allow failure because we'll fall back if this fails
        continue-on-error: true
  
      # 9) Merge step: Prefer MergeResults (CMDRunner) if installed; otherwise fallback to concatenation
      - name: Merge JTL files (MergeResults preferred, fallback to concat)
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p final-results
  
          # Build candidate search paths:
          SEARCH_PATHS=( "merged-results/unzipped" "merged-results" )
  
          # Collect all JTLs (search recursively)
          JTLS_RAW=()
          for p in "${SEARCH_PATHS[@]}"; do
            if [ -d "$p" ]; then
              while IFS= read -r -d $'\0' f; do
                JTLS_RAW+=("$f")
              done < <(find "$p" -type f -name "*.jtl" -print0 || true)
            fi
          done
  
          # Normalize unique list
          declare -A _seen
          JTLS=()
          for f in "${JTLS_RAW[@]}"; do
            if [ -n "$f" ] && [ -f "$f" ]; then
              if [ -z "${_seen[$f]:-}" ]; then
                _seen[$f]=1
                JTLS+=( "$f" )
              fi
            fi
          done
  
          if [ ${#JTLS[@]} -eq 0 ]; then
            echo "‚ùå No JTL files found in merged-results or merged-results/unzipped"
            echo "Debug listing (merged-results recursive):"
            find merged-results -type f -maxdepth 10 -print || true
            exit 1
          fi
  
          echo "‚úÖ Found ${#JTLS[@]} JTL files:"
          for f in "${JTLS[@]}"; do
            echo " - $f"
          done
  
          # Decide whether to attempt MergeResults via ReportsGenerator
          CMD_JAR="$HOME/jmeter/lib/cmdrunner-2.3.jar"
          MERGERESULTS_JAR=$(find "$HOME/jmeter/lib/ext" -type f -name "*mergeresults*.jar" -print -quit || true)
          MERGE_INSTALLED=false
  
          if [ -f "$CMD_JAR" ] && [ -n "$MERGERESULTS_JAR" ]; then
            echo "‚ÑπÔ∏è CMDRunner and MergeResults jar detected; attempting ReportsGenerator merge."
            PLUGIN_CP=$(find "$HOME/jmeter/lib/ext" -name "*.jar" -printf "%p:" | sed 's/:$//')
            MERGED_JTL="final-results/merged.jtl"
  
            echo "Running ReportsGenerator (CMDRunner) to merge..."
            java -cp "$CMD_JAR:$PLUGIN_CP" kg.apc.cmdtools.ReportsGenerator \
              --generate-csv "$MERGED_JTL" \
              --input-jtl "${JTLS[@]}" && {
                MERGE_INSTALLED=true
              } || {
                echo "‚ö†Ô∏è ReportsGenerator failed; falling back to simple concat merge"
                MERGE_INSTALLED=false
              }
  
            if [ -f "$MERGED_JTL" ]; then
              echo "‚úÖ ReportsGenerator merged JTL to: $MERGED_JTL"
            else
              echo "‚ö†Ô∏è ReportsGenerator did not produce merged JTL; will try fallback merge."
              MERGE_INSTALLED=false
            fi
          else
            echo "‚ö†Ô∏è CMDRunner or MergeResults jar not present; will use fallback concatenation merge."
            MERGE_INSTALLED=false
          fi
  
          # Fallback: header + tail concatenation
          if [ "$MERGE_INSTALLED" = "false" ] || [ ! -f "final-results/merged.jtl" ]; then
            echo "Using fallback concatenation merge (header + append bodies)..."
            FIRST="$(printf "%s\n" "${JTLS[@]}" | head -n1)"
            if [ -z "$FIRST" ] || [ ! -f "$FIRST" ]; then
              echo "‚ùå Unexpected: first file not found: $FIRST"
              exit 1
            fi
  
            echo "Copying header from: $FIRST"
            head -n 1 "$FIRST" > final-results/merged.jtl
  
            # Append bodies from each JTL (skip header line)
            for f in "${JTLS[@]}"; do
              echo "Appending (without header): $f"
              tail -n +2 "$f" >> final-results/merged.jtl || true
            done
            echo "‚úÖ Fallback merged JTL created at final-results/merged.jtl"
          fi
  
      # 10) Generate HTML dashboard from merged.jtl (if present)
      - name: Generate merged HTML report (if merged.jtl exists)
        shell: bash
        run: |
          set -e
          MERGED_JTL="final-results/merged.jtl"
          REPORT_DIR="final-results/merged-report"
          if [ -f "$MERGED_JTL" ]; then
            echo "Generating JMeter HTML report from $MERGED_JTL -> $REPORT_DIR"
            # jmeter -g <jtl> -o <outdir>
            "$HOME/jmeter/bin/jmeter" -g "$MERGED_JTL" -o "$REPORT_DIR" || {
              echo "‚ö†Ô∏è jmeter -g failed; report generation skipped"
            }
            echo "‚úÖ HTML report generation step completed (if no errors above)."
          else
            echo "‚ùå No merged.jtl found; skipping HTML report generation."
          fi
  
      # 11) Package and upload final results
      - name: Package consolidated artifacts
        run: |
          set -e
          mkdir -p final-upload
          # Copy the runner uploads for traceability (if any)
          cp -r merged-results final-upload/ || true
          # Copy merged outputs
          cp -r final-results final-upload/ || true
          zip -r consolidated-results.zip final-upload || true
          echo "Packaged consolidated-results.zip"
  
      - name: Upload consolidated artifact
        uses: actions/upload-artifact@v4
        with:
          name: consolidated-jmeter-results
          path: consolidated-results.zip
          retention-days: ${{ github.event.inputs.cleanup_days }}
          
# =========================================================
# Job 4: Cleanup old artifacts
# =========================================================
  cleanup-artifacts:
    if: ${{ github.event.inputs.test_type == 'cleanup' }}
    runs-on: ubuntu-latest
    steps:
      - name: Install GitHub CLI
        run: |
          sudo apt-get update
          sudo apt-get install -y gh
  
      - name: Authenticate GitHub CLI
        run: gh auth login --with-token <<< "${{ secrets.GITHUB_TOKEN }}"
  
      - name: Cleanup old runner result directories
        run: |
          echo "üßπ Cleaning local runner report directories older than ${{ github.event.inputs.cleanup_days }} days..."
          if [ -d "${{ env.REPORT_DIR }}" ]; then
            find ${{ env.REPORT_DIR }} -maxdepth 1 -type d -name "*-runner-*" -mtime +${{ github.event.inputs.cleanup_days }} -exec rm -rf {} +
            echo "‚úÖ Old local runner directories deleted."
          else
            echo "‚ÑπÔ∏è Local report directory not found; skipping local cleanup."
          fi
  
      - name: Cleanup old GitHub Actions artifacts
        run: |
          echo "üßπ Cleaning GitHub Actions artifacts older than ${{ github.event.inputs.cleanup_days }} days..."
          gh api repos/${{ github.repository }}/actions/artifacts \
            --paginate \
            --jq ".artifacts[] | select((now - (.created_at | fromdate)) / 86400 > ${{ github.event.inputs.cleanup_days }}) | .id" \
            | while read artifact_id; do
              echo "Deleting artifact ID: $artifact_id"
              gh api -X DELETE repos/${{ github.repository }}/actions/artifacts/$artifact_id
            done
          echo "‚úÖ GitHub Actions artifacts cleanup complete."
